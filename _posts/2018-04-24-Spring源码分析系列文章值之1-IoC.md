---
layout: post
title: 'Spring源码分析系列文章值之1-IoC'
subtitle: 'IoC（控制反转）是 Spring 提供的核心功能，本文通过分析 Spring 源码来了解 IoC 的过程。'
date: 2018-04-24
categories: 技术
tags: Spring 源码分析 java
---

# Spring 1.0 源码分析系列之 IoC

> beans 和 context 两个包是 Spring 框架中 IoC 容器的基础，BeanFactory 接口提供一种高级的配置机制能够管理任何类型的对象。ApplicationContext 是BeanFactory 的子接口。它能更容易集成 Spring 的 AOP 功能、消息资源处理（比如在国际化中使用）、事件发布和特定的上下文应用层比如在网站应用中的 WebApplicationContext。

> 总之，BeanFactory 提供了配置框架和基本方法，ApplicationContext 添加更多的企业特定的功能，ApplicationContext 是 BeanFactory 的一个子接口。

## 1. 启动入口

### 1.1 DispatcherServlet 

这个类留在 web 模块再分析

### 1.2 ContextLoaderListener
一个典型的 web 应用通常都是通过在 tomcat 的 web.xml 文件里通过配置 ServletContextListener 来引入 Spring, 如下：

```XML
<listener>
	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```

ContextLoaderListener 实现了 `ServletContextListener` 接口，是初始化 spring 的根 `WebApplicationContext` 的启动类。`ContextLoaderListener` 代码如下：

```java
public class ContextLoaderListener implements ServletContextListener {
    private ContextLoader contextLoader;

    public void contextInitialized(ServletContextEvent event) {
        this.contextLoader = createContextLoader();
        this.contextLoader.initWebApplicationContext(event.getServletContext());
    }

    protected ContextLoader createContextLoader() {
        return new ContextLoader();
    }

    public void contextDestroyed(ServletContextEvent event) {
        this.contextLoader.closeWebApplicationContext(event.getServletContext());
    }
}
```

当 Servlet 容器启动或终止Web 应用时，会触发 `ServletContextEvent` 事件，该事件由 `ServletContextListener` 来处理。

当 Servlet 容器启动 Web 应用时会调用 `contextInitialized()` 方法。在调用完该方法之后，容器再对 Filter 初始化，并且对那些在 Web 应用启动时就需要被初始化的 Servlet 进行初始化。

当 Servlet 容器终止 Web 应用时调用 `contextDestroyed()` 方法。在调用该方法之前，容器会先销毁所有的 Servlet 和 Filter 过滤器。

Servlet 2.2 和 Servlet 2.3 的 Servlet 容器并不会在 servelet 初始化之前先初始化 `ServletContextListener`，针对这两个特殊的 Servlet 实现，Spring 提供了一个实现了完全同样代码的 `ContextLoaderServlet` 来替代。

### 1.3 ServletContext
`ServletContext` 是 servlet 与 servlet 容器之间的直接通信的接口。Servlet 容器在启动一个 Web 应用时，会为它创建一个 `servletContext` 对象。每个 web 应用有唯一的 `servletContext` 对象。同一个 web 应用的所有 servlet 对象共享一个 `serveltContext`, servlet  对象可以通过它来访问容器中的各种资源。

`javax.servlet.ServletContext`，具体到 tomcat 的实现类是 `org.apache.catalina.core.ApplicationContext`，jsp 中 9 个内置对象的 application 就是这个对象。

`ServletContext` 对象获得的几种方式：

```java
Javax.servlet.http.HttpSession.getServletContext() 

Javax.servlet.jsp.PageContext.getServletContext() 

Javax.servlet.ServletConfig.getServletContext()
```

### 1.4 ContextLoader
`ContextLoader` 是 `ContextLoaderListener` 的实际功能承担者， `ContextLoaderListener` 在 Servlet 容器启动 Web 应用时执行下面的代码：

```java
// 仅仅是 new 了一个 ContextLoader
this.contextLoader = createContextLoader();

// 初始化一个 WebApplicationContext，并设置到 servletContext 的 Attribute 里面
this.contextLoader.initWebApplicationContext(event.getServletContext());
```

`contextLoader` 初始化 `WebApplicationContext` 的过程：

```java
public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
    servletContext.log("Loading root WebApplicationContext");

    // ...

    // 空的实现
    ApplicationContext parent = loadParentContext(servletContext);
    
    // 创建一个 WebApplicationContext
    WebApplicationContext wac = createWebApplicationContext(servletContext, parent);
    
    // 把 ApplicationContext 放在 servletContext 属性里面，避免 gc
    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
    
    // ...
    
    return wac;
}
```

创建一个 `WebApplicationContext` 的过程：

```java
protected WebApplicationContext createWebApplicationContext(ServletContext servletContext, ApplicationContext parent) {
    String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);
    Class contextClass = XmlWebApplicationContext.class;

    // 如果配置了 contextClass，则使用用户配置的类作为 WebApplicationContext
    if (contextClassName != null) {
        contextClass = Class.forName(contextClassName, true, Thread.currentThread().getContextClassLoader());
        
        // 必须是 ConfigurableWebApplicationContext 的子类
        if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
            throw new ApplicationContextException();
        }
    }

    // 反射实例化
    ConfigurableWebApplicationContext wac = BeanUtils.instantiateClass(contextClass);
    wac.setParent(parent);
    wac.setServletContext(servletContext);

    // 用户自定义的 xml 配置文件路径，通过 contextConfigLocation 属性，支持多个用逗号隔开
    String configLocation = servletContext.getInitParameter(CONFIG_LOCATION_PARAM);
    if (configLocation != null) {
        wac.setConfigLocations(StringUtils.tokenizeToStringArray(configLocation, "", true, true));
    }

    // 这个方法会把所有的 bean 实例化
    wac.refresh();
    return wac;
}
```

具体实现，判断 init-param 配置的 contextClass 是哪个，没有的话，默认使用 `XmlWebApplicationContext`。且 contextClass 必须是 `ConfigurableWebApplicationContext` 接口的实现。接下来通过反射来实例化 `XmlWebApplicationContext`，并设置一些 context、parent 之类的属性，并调用 `setServletContext(servletContext)` 方法

`setServletContext(servletContext)` 方法和之前的不同，仅仅是作为了一个普通的 setter 方法。更重要的初始化所有 bean 的操作被放在了 `refresh()` 中，这个方法是 spring IoC的核心，我们在后面的内容会详细介绍。

我们看到，ServletContext 和 WebApplicationContext 相互持有了对方的引用，这样的设计为后续的业务开发中无疑提供了很方便的api。

spring 0.9.1中的 `setServletContext` 方法。

```java
public void setServletContext(ServletContext servletContext) throws ApplicationContextException {
    this.servletContext = servletContext;
    this.configLocation = initConfigLocation();
    
    refresh();
    
    if (this.namespace == null) {
        // We're the root context
        WebApplicationContextUtils.publishConfigObjects(this);
        // Expose as a ServletContext object
        WebApplicationContextUtils.publishWebApplicationContext(this);
    }   
}
```

## 2. BeanFactory及其家族

继承树关系，[点此查看大图](https://note.youdao.com/yws/public/resource/d521198d0cfadf35fd752967d4d69eea/xmlnote/WEBRESOURCE37357449f54b2a6ad541b8215cd13fd6/8345)：

![image](/assets/img/20180424/QQ20180424-124009.png)

上面的图是我整理出来的 Spring 1.0 版本的 BeanFactory、 ApplicationContext 及其家族的关系图，我想每个看到这张图的 Spring 源码学习者都会被这么复杂的继承关系吓的萌生退意，再也不会继续学习下去了，但很多 Spring 学习的资料总是从这一坨类的关系开始将其，真让人头大，不为别的，就是因为这些类的关系非常重要。所以我试着将这些类的给慢慢地捋一遍，捋的过程你只需要看着上面的图，心中有个大概的了解就好了。

### 2.1 BeanFactory
首先我们从 BeanFactory 接口开始。这个类是我们接下来要说的所有类、接口最根上的，也是 Spring 最核心的接口。所以这个接口的功能和方法需要你牢牢记住。

BeanFactory 我们看名字可以知道，这是一个产生 bean 的工厂。它一共就只有5个方法。一个根据指定名称获得 bean 对象的方法，一个根据指定名称和 class 类型获得 bean 对象的方法，一个返回此 bean 工厂是否含有指定名称的 bean 的方法，一个判断 bean 是否是单例的方法，最后一个是获得 bean 的别名。五个方法都是和 获取 bean 或者 bean 相关的信息有关。

所以我们第一个需要记住的接口 BeanFactory， 非常简单，要么用于获得 bean，要么用于获得 bean 的信息。正如其名 「bean 工厂」。


```java
// 根据指定名称获得 bean 对象
Object getBean(String name) throws BeansException;

// 根据指定名称和 class 类型获得 bean 对象
Object getBean(String name, Class requiredType) throws BeansException;

// 返回此 bean 工厂是否含有指定名称的 bean
boolean containsBean(String name);

boolean isSingleton(String name) throws NoSuchBeanDefinitionException;

String[] getAliases(String name) throws NoSuchBeanDefinitionException;
```

### 2.2 BeanFactory的扩展接口
我们现在了解了 BeanFactory 接口的功能，再看上面的继承关系图。我们可以发现，左半边的接口和类名字里都带着「 XxxBeanFactory 」的字样，这说明这些接口或类在 BeanFactory 的基础上扩展了功能，这些功能都是和获得 bean 的信息有关，我们只需要看一下类或接口的名字，就能大致猜出它的功能。例如：

**HierarchicalBeanFactory** 接口。Hierarchical有「分层的、层级的」意思，所以不难理解，这个类可以让 BeanFactory 具有分层的功能，所以它提供了一个 `getParentBeanFactory()` 方法。

**ListableBeanFactory** 接口。Listable有「可罗列的」意思，所以 ListableBeanFactory 可以把所有的 bean 对象遍历出来，所以它提供了以下接口：

```java
// 返回factory中定义的所有bean数量。不考虑其他层次的factory
int getBeanDefinitionCount();

// 返回factory中定义的所有bean name。不考虑其他层次的factory
String[] getBeanDefinitionNames();

// 返回所有类型的bean名称，包括class的所有子类型
String[] getBeanDefinitionNames(Class type);

// 判断是否包含指定名字的 bean 
boolean containsBeanDefinition(String name);

// 返回一个 map 包含了指定类型的 bean，key 为 bean name， value 为 bean 对象
Map getBeansOfType(Class type, boolean includePrototypes, boolean includeFactoryBeans) throws BeansException;
```

**AutowireCapableBeanFactory** 接口。AutowireCapable 的意思是「有能力自动装配的」，这个接口一般在 Spring 内部是较少使用的，它的功能主要是为了装配 Spring 管理之外的 Bean，例如 Filter、Servlet 类，当这些类需要一个 Spring bean的时候，你可以通过本接口来把需要的 bean 注入进来。

[AutowireCapableBeanFactory 源码解读](https://my.oschina.net/zhuqianli/blog/886055) 

[AutowireCapableBeanFactory 使用](http://412887952-qq-com.iteye.com/blog/2376215)

[how-do-i-manually-autowire-a-bean-with-spring](https://stackoverflow.com/questions/11965600/how-do-i-manually-autowire-a-bean-with-spring)

**ConfigurableBeanFactory** 接口。顾名思义，专门为了 Spring 内部设置 BeanFactory 的一些属性而暴露的接口，有了这些接口，Spring 在管理 bean 的时候可以有些缓存之类的（例如已经创建的单例、beanDefinition、 bean 的别名等）。这个类提供的接口绝大多数的实现都是通过把配置注册到一个 Map 或者 List 中。

提供方法：

```java
void setParentBeanFactory(BeanFactory parentBeanFactory);
void registerCustomEditor(Class requiredType, PropertyEditor propertyEditor);
void ignoreDependencyType(Class type);
void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);
BeanDefinition getBeanDefinition(String beanName) throws BeansException;
void registerAlias(String beanName, String alias) throws BeansException;
void registerSingleton(String beanName, Object singletonObject) throws BeansException;
void destroySingletons();
```

**ConfigurableListableBeanFactory** 接口。这个接口比较有趣，这个接口继承了前面涉及到的所有的 BeanFactory 扩展接口，自身只有一个方法 `preInstantiateSingletons()`，这个方法是为了保证所有非延迟初始化的 bean 都实例化，这个方法调用之后，所有 Spring 管理的非延迟初始化的 bean 都被装配好实例化了。

提供方法：

```java
// 这个方法调用之后，所有 Spring 管理的非延迟初始化的 bean 都会被装配好并实例化，可以直接 getBean() 来用了
void preInstantiateSingletons()
```

### 2.3 BeanFactory 接口的几个主要的实现

**AbstractBeanFactory** 类是 BeanFactory 的第一个实现，后面所有其他 BeanFactory 接口的扩展接口的时间几乎都是继承了 AbstractBeanFactory 类。AbstractBeanFactory 实现了 `getBean()` 方法，主要是从缓存的 map 里获取 bean 对象，当 map 缓存里面没有的时候，则会调用 `createBean()` 方法，但 AbstractBeanFactory 并没有实现 `createBean()` 方法， `createBean()` 方法是在 **AbstractAutowireCapableBeanFactory** 类中事件的。 AbstractAutowireCapableBeanFactory 类继承自 AbstractBeanFactory 类，并实现了 AutowireCapableBeanFactory 接口，如下图。

![image](/assets/img/20180424/QQ20180424-124009.png)

**DefaultListableBeanFactory** 类和 **XmlBeanFactory** 类，DefaultListableBeanFactory 类继承了 AbstractAutowireCapableBeanFactory 类，实现了它的一些抽象方法，从名字上看，应该实现了 ListableBeanFactory 接口，即可以遍历出来所有的 bean 。确实，DefaultListableBeanFactory 实现了绝大部分的 BeanFactory 接口和其扩展接口提供的方法，但是 DefaultListableBeanFactory 仍然不能做到开箱即用，因为 DefaultListableBeanFactory 没有解决一个最关键的问题，就是 bean 是从哪儿来的问题，这个问题由 DefaultListableBeanFactory 的子类 XmlBeanFactory 解决的，我们从 XmlBeanFactory 的名字就知道这个类是做什么的了，没错，从 xml 解析出来所有的 bean。 XmlBeanFactory 的构造函数就要求传入一个"数据源"，构造函数执行完毕，所有的 bean 就从构造函数指定的"数据源"解析完成了。具体的操作是由 XmlBeanDefinitionReader 完成的，我们后面再分析这个解析 xml 的过程。

## 3. ApplicationContext 接口及其家族

### 3.1 ApplicationContext接口
接下来，我们再来看 Spring IoC 另外一个非常重要的顶级接口 **ApplicationContext**，通过前面的关系图，我们可以看到，ApplicationContext 接口继承了 BeanFactory 接口，所以我们可以说 ApplicationContext 也是一种 Bean 工厂。 虽然 ApplicationContext 继承了 BeanFactory，也有了 bean 的例化/装配等功能，但是这部分的功能却是 ApplicationContext 持有了一个 BeanFactory 的实现的引用来完成的，所有 BeanFactory 的操作由这个引用来代理。 

> ApplicationContext 能更容易集成 Spring 的 AOP 功能、消息资源处理（比如在国际化中使用）、事件发布和特定的上下文应用层比如在网站应用中的 WebApplicationContext。

> BeanFactory 提供了配置框架和基本方法，ApplicationContext 添加更多的企业特定的功能。

BeanFactory 和 ApplicationContext 不同的功能，可以看官方的文档的介绍（来自 Spring 5 的中文文档）：

Feature | BeanFactory | ApplicationContext
---|---|---
Bean 实例化/装配 | 是 | 是
BeanPostProcessor 自动注册 | 否 | 是
BeanFactoryPostProcessor 自动注册 | 否 | 是
MessageSource 便捷访问（针对i18n） | 否 | 是
ApplicationEvent 发布 | 否 | 是

ApplicationContext 接口提供的方法：

```java
// 获得父类上下文
ApplicationContext getParent(); 

// 返回一个友好的上下文名称，例如: "Root WebApplicationContext"、"WebApplicationContext for namespace xxx"
String getDisplayName(); 

// 返回此上下文首次加载的时间戳，refresh()方法调用的时间
long getStartupDate();

// refresh()的时候会调用refreshListeners()找出所有实现了ApplicationListener的bean，作为观察者
void publishEvent(ApplicationEvent event);
```

### 3.2 ApplicationContext 接口的扩展接口
**WebApplicationContext** 接口。WebApplicationContext 接口继承了 ApplicationContext 接口，另外额外增加一个方法，可以用来获得 ServletContext，非常简单明了。

```java
ServletContext getServletContext();
```

**ConfigurableApplicationContext** 接口。和 ConfigurableBeanFactory 接口类似，提供了一些方法来对 ApplicationContext 进行设置。注意，其中有个 `refresh()` 方法，是 IoC 的入口，请先记在心里这个方法，我们在后面反复提到，并详细分析它的实现的代码。

```java
// 设置 parent ApplicationContext
void setParent(ApplicationContext parent);

// 增加一个 BeanFactoryPostProcessor，会在 refresh() 的时候生效
void addBeanFactoryPostProcessor(BeanFactoryPostProcessor beanFactoryPostProcessor);

// 由此初始化所有 bean
void refresh() throws BeansException;

// 返回 ApplicationContext 持有的 ConfigurableListableBeanFactory，这是一个继承的比较全的接口，前面应该记得的。
ConfigurableListableBeanFactory getBeanFactory();

// 关闭 ApplicationContext
void close() throws ApplicationContextException;
```

**ConfigurableWebApplicationContext** 接口。同样，提供了一些方法来对 WebApplicationContext 进行设置。

```java
// 对应于 WebApplicationContext 的 getServletContext() 方法
void setServletContext(ServletContext servletContext);

// 设置一个比较简单的名字
void setNamespace(String namespace);

// 设置配置文件的路径，如果不设置，会用一个默认的。
void setConfigLocations(String[] configLocations);
```

### 3.3 ApplicationContext 接口的主要实现
**AbstractApplicationContext** 类。本类最关键的是实现了 ConfigurableApplicationContext 接口的 `refresh()` 方法，前面已经多次提到，这个方法是 IoC 的入口。我们先记这一点，后面再详细分析 refresh() 方法。

AbstractApplicationContext 类中有个抽象方法 `refreshBeanFactory()`，用来构造一个BeanFactory。前面已经说了，ApplicationContext 中所有 和 bean 装配和初始化的部分都是一个 BeanFactory 来代理完成的。这个方法在 **AbstractXmlApplicationContext** 中得以实现。使用的 BeanFactory 实现是 DefaultListableBeanFactory。

**XmlWebApplicationContext**

**ClassPathXmlApplicationContext**

**FileSystemXmlApplicationContext**

## 4. BeanFactory、ApplicationContext家族的总结
我们分析完了 Spring 对接口的设计，可以看出 Spring 对接口的设计非常细化，每个接口的职责划分的非常清楚，是什么接口就只能做什么事情，通过看一个接口的名字就知道这个接口能做什么。我们不禁要问，为什么要这么设计？所有的方法都在一个接口里不行么？答案是，这样的设计是符合设计模式六大原则之四的**接口隔离原则**。

> Interface Segregation Principle（ ISP ) ：客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上

我们可以看到， Spring 在设计接口的时候完全遵照了接口隔离原则，把任何将来可能变化的功能都抽象出来一个接口，从而做到了把类和类之间的耦合关系降到了最低。这也是 Spring 后来不断推出各种各样的功能，而几个核心的概念却一直没有多少变化。再想想平时自己写的代码。。。所以，大神们写的代码就是不一样。

# 未完待续

