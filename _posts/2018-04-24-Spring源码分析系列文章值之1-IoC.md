---
layout: post
title: 'Spring源码分析系列文章值之1-IoC'
subtitle: 'IoC（控制反转）是 Spring 提供的核心功能，本文通过分析 Spring 源码来了解 IoC 的过程。'
date: 2018-04-24
categories: 技术
tags: Spring 源码分析 java
---

# Spring 1.0 源码分析系列之 IoC

> beans 和 context 两个包是 Spring 框架中 IoC 容器的基础，BeanFactory 接口提供一种高级的配置机制能够管理任何类型的对象。ApplicationContext 是BeanFactory 的子接口。它能更容易集成 Spring 的 AOP 功能、消息资源处理（比如在国际化中使用）、事件发布和特定的上下文应用层比如在网站应用中的 WebApplicationContext。

> 总之，BeanFactory 提供了配置框架和基本方法，ApplicationContext 添加更多的企业特定的功能，ApplicationContext 是 BeanFactory 的一个子接口。

## 启动入口

### DispatcherServlet 

这个类留在 web 模块再分析

### ContextLoaderListener
一个典型的 web 应用通常都是通过在 tomcat 的 web.xml 文件里通过配置 ServletContextListener 来引入 Spring, 如下：

```XML
<listener>
	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```

ContextLoaderListener 实现了 `ServletContextListener` 接口，是初始化 spring 的根 `WebApplicationContext` 的启动类。`ContextLoaderListener` 代码如下：

```java
public class ContextLoaderListener implements ServletContextListener {
    private ContextLoader contextLoader;

    public void contextInitialized(ServletContextEvent event) {
        this.contextLoader = createContextLoader();
        this.contextLoader.initWebApplicationContext(event.getServletContext());
    }

    protected ContextLoader createContextLoader() {
        return new ContextLoader();
    }

    public void contextDestroyed(ServletContextEvent event) {
        this.contextLoader.closeWebApplicationContext(event.getServletContext());
    }
}
```

当 Servlet 容器启动或终止Web 应用时，会触发 `ServletContextEvent` 事件，该事件由 `ServletContextListener` 来处理。

当 Servlet 容器启动 Web 应用时会调用 `contextInitialized()` 方法。在调用完该方法之后，容器再对 Filter 初始化，并且对那些在 Web 应用启动时就需要被初始化的 Servlet 进行初始化。

当 Servlet 容器终止 Web 应用时调用 `contextDestroyed()` 方法。在调用该方法之前，容器会先销毁所有的 Servlet 和 Filter 过滤器。

Servlet 2.2 和 Servlet 2.3 的 Servlet 容器并不会在 servelet 初始化之前先初始化 `ServletContextListener`，针对这两个特殊的 Servlet 实现，Spring 提供了一个实现了完全同样代码的 `ContextLoaderServlet` 来替代。

### ServletContext
`ServletContext` 是 servlet 与 servlet 容器之间的直接通信的接口。Servlet 容器在启动一个 Web 应用时，会为它创建一个 `servletContext` 对象。每个 web 应用有唯一的 `servletContext` 对象。同一个 web 应用的所有 servlet 对象共享一个 `serveltContext`, servlet  对象可以通过它来访问容器中的各种资源。

`javax.servlet.ServletContext`，具体到 tomcat 的实现类是 `org.apache.catalina.core.ApplicationContext`，jsp 中 9 个内置对象的 application 就是这个对象。

`ServletContext` 对象获得的几种方式：

```java
Javax.servlet.http.HttpSession.getServletContext() 

Javax.servlet.jsp.PageContext.getServletContext() 

Javax.servlet.ServletConfig.getServletContext()
```

### ContextLoader
`ContextLoader` 是 `ContextLoaderListener` 的实际功能承担者， `ContextLoaderListener` 在 Servlet 容器启动 Web 应用时执行下面的代码：

```java
// 仅仅是 new 了一个 ContextLoader
this.contextLoader = createContextLoader();

// 初始化一个 WebApplicationContext，并设置到 servletContext 的 Attribute 里面
this.contextLoader.initWebApplicationContext(event.getServletContext());
```

`contextLoader` 初始化 `WebApplicationContext` 的过程：

```java
public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
    servletContext.log("Loading root WebApplicationContext");

    // ...

    // 空的实现
    ApplicationContext parent = loadParentContext(servletContext);
    
    // 创建一个 WebApplicationContext
    WebApplicationContext wac = createWebApplicationContext(servletContext, parent);
    
    // 把 ApplicationContext 放在 servletContext 属性里面，避免 gc
    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
    
    // ...
    
    return wac;
}
```

创建一个 `WebApplicationContext` 的过程：

```java
protected WebApplicationContext createWebApplicationContext(ServletContext servletContext, ApplicationContext parent) {
    String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);
    Class contextClass = XmlWebApplicationContext.class;

    // 如果配置了 contextClass，则使用用户配置的类作为 WebApplicationContext
    if (contextClassName != null) {
        contextClass = Class.forName(contextClassName, true, Thread.currentThread().getContextClassLoader());
        
        // 必须是 ConfigurableWebApplicationContext 的子类
        if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
            throw new ApplicationContextException();
        }
    }

    // 反射实例化
    ConfigurableWebApplicationContext wac = BeanUtils.instantiateClass(contextClass);
    wac.setParent(parent);
    wac.setServletContext(servletContext);

    // 用户自定义的 xml 配置文件路径，通过 contextConfigLocation 属性，支持多个用逗号隔开
    String configLocation = servletContext.getInitParameter(CONFIG_LOCATION_PARAM);
    if (configLocation != null) {
        wac.setConfigLocations(StringUtils.tokenizeToStringArray(configLocation, "", true, true));
    }

    // 这个方法会把所有的 bean 实例化
    wac.refresh();
    return wac;
}
```

具体实现，判断 init-param 配置的 contextClass 是哪个，没有的话，默认使用 `XmlWebApplicationContext`。且 contextClass 必须是 `ConfigurableWebApplicationContext` 接口的实现。接下来通过反射来实例化 `XmlWebApplicationContext`，并设置一些 context、parent 之类的属性，并调用 `setServletContext(servletContext)` 方法

`setServletContext(servletContext)` 方法和之前的不同，仅仅是作为了一个普通的 setter 方法。更重要的初始化所有 bean 的操作被放在了 `refresh()` 中，这个方法是 spring IoC的核心，我们在后面的内容会详细介绍。

我们看到，ServletContext 和 WebApplicationContext 相互持有了对方的引用，这样的设计为后续的业务开发中无疑提供了很方便的api。

spring 0.9.1中的 `setServletContext` 方法。

```java
public void setServletContext(ServletContext servletContext) throws ApplicationContextException {
    this.servletContext = servletContext;
    this.configLocation = initConfigLocation();
    
    refresh();
    
    if (this.namespace == null) {
        // We're the root context
        WebApplicationContextUtils.publishConfigObjects(this);
        // Expose as a ServletContext object
        WebApplicationContextUtils.publishWebApplicationContext(this);
    }   
}
```

### BeanFactory、ApplicationContext及其家族

继承树关系，[点此查看大图](https://note.youdao.com/yws/public/resource/d521198d0cfadf35fd752967d4d69eea/xmlnote/WEBRESOURCE37357449f54b2a6ad541b8215cd13fd6/8345)：

![image](/assets/img/20180424/QQ20180424-124009.png)

上面的图是我整理出来的 Spring 1.0 版本的 BeanFactory、 ApplicationContext 及其家族的关系图，我想每个看到这张图的 Spring 源码学习者都会被这么复杂的继承关系吓的萌生退意，再也不会继续学习下去了，但很多 Spring 学习的资料总是从这一坨类的关系开始将其，真让人头大，不为别的，就是因为这些类的关系非常重要。所以我试着将这些类的给慢慢地捋一遍，捋的过程你只需要看着上面的图，心中有个大概的了解就好了。

#### 根接口 BeanFactory
首先我们从 BeanFactory 接口开始。这个类是我们接下来要说的所有类、接口最根上的，也是 Spring 最核心的接口。所以这个接口的功能和方法需要你牢牢记住。

BeanFactory 我们看名字可以知道，这是一个产生 bean 的工厂。它一共就只有5个方法。一个根据指定名称获得 bean 对象的方法，一个根据指定名称和 class 类型获得 bean 对象的方法，一个返回此 bean 工厂是否含有指定名称的 bean 的方法，一个判断 bean 是否是单例的方法，最后一个是获得 bean 的别名。五个方法都是和 获取 bean 或者 bean 相关的信息有关。

所以我们第一个需要记住的接口 BeanFactory， 非常简单，要么用于获得 bean，要么用于获得 bean 的信息。正如其名 「bean 工厂」。


```java
// 根据指定名称获得 bean 对象
Object getBean(String name) throws BeansException;

// 根据指定名称和 class 类型获得 bean 对象
Object getBean(String name, Class requiredType) throws BeansException;

// 返回此 bean 工厂是否含有指定名称的 bean
boolean containsBean(String name);

boolean isSingleton(String name) throws NoSuchBeanDefinitionException;

String[] getAliases(String name) throws NoSuchBeanDefinitionException;
```

#### BeanFactory的扩展接口
我们现在了解了 BeanFactory 接口的功能，再看上面的继承关系图。我们可以发现，左半边的接口和类名字里都带着「 XxxBeanFactory 」的字样，这说明这些接口或类在 BeanFactory 的基础上扩展了功能，这些功能都是和获得 bean 的信息有关，我们只需要看一下类或接口的名字，就能大致猜出它的功能。例如：

**HierarchicalBeanFactory** 接口。Hierarchical有「分层的、层级的」意思，所以不难理解，这个类可以让 BeanFactory 具有分层的功能，所以它提供了一个 `getParentBeanFactory()` 方法。

**ListableBeanFactory** 接口。Listable有「可罗列的」意思，所以 ListableBeanFactory 可以把所有的 bean 对象遍历出来，所以它提供了以下接口：

```java
// 返回factory中定义的所有bean数量。不考虑其他层次的factory
int getBeanDefinitionCount();

// 返回factory中定义的所有bean name。不考虑其他层次的factory
String[] getBeanDefinitionNames();

// 返回所有类型的bean名称，包括class的所有子类型
String[] getBeanDefinitionNames(Class type);

// 判断是否包含指定名字的 bean 
boolean containsBeanDefinition(String name);

// 返回一个 map 包含了指定类型的 bean，key 为 bean name， value 为 bean 对象
Map getBeansOfType(Class type, boolean includePrototypes, boolean includeFactoryBeans) throws BeansException;
```

**AutowireCapableBeanFactory** 接口。AutowireCapable 的意思是「有能力自动装配的」，这个接口一般在 Spring 内部是较少使用的，它的功能主要是为了装配 Spring 管理之外的 Bean，例如 Filter、Servlet 类，当这些类需要一个 Spring bean的时候，你可以通过本接口来把需要的 bean 注入进来。

[AutowireCapableBeanFactory 源码解读](https://my.oschina.net/zhuqianli/blog/886055) 

[AutowireCapableBeanFactory 使用](http://412887952-qq-com.iteye.com/blog/2376215)

[how-do-i-manually-autowire-a-bean-with-spring](https://stackoverflow.com/questions/11965600/how-do-i-manually-autowire-a-bean-with-spring)

**ConfigurableBeanFactory** 接口。顾名思义，专门为了 Spring 内部设置 BeanFactory 的一些属性而暴露的接口，有了这些接口，Spring 在管理 bean 的时候可以有些缓存之类的（例如已经创建的单例、beanDefinition、 bean 的别名等）。这个类提供的接口绝大多数的实现都是通过把配置注册到一个 Map 或者 List 中。

提供方法：

```java
void setParentBeanFactory(BeanFactory parentBeanFactory);
void registerCustomEditor(Class requiredType, PropertyEditor propertyEditor);
void ignoreDependencyType(Class type);
void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);
BeanDefinition getBeanDefinition(String beanName) throws BeansException;
void registerAlias(String beanName, String alias) throws BeansException;
void registerSingleton(String beanName, Object singletonObject) throws BeansException;
void destroySingletons();
```

**ConfigurableListableBeanFactory** 接口。这个接口比较有趣，这个接口继承了前面涉及到的所有的 BeanFactory 扩展接口，自身只有一个方法 `preInstantiateSingletons()`，这个方法是为了保证所有非延迟初始化的 bean 都实例化，这个方法调用之后，所有 Spring 管理的非延迟初始化的 bean 都被装配好实例化了。

提供方法：

```java
// 这个方法调用之后，所有 Spring 管理的非延迟初始化的 bean 都会被装配好并实例化，可以直接 getBean() 来用了
void preInstantiateSingletons()
```

#### BeanFactory 接口的两个主要的实现

#### BeanFactory、ApplicationContext家族的总结
我们分析完了 Spring 对接口的设计，可以看出 Spring 对接口的设计非常细化，每个接口的职责划分的非常清楚，是什么接口就只能做什么事情，通过看一个接口的名字就知道这个接口能做什么。我们不禁要问，为什么要这么设计？所有的方法都在一个接口里不行么？答案是，这样的设计是符合设计模式六大原则之四的接口隔离原则。

> Interface Segregation Principle（ ISP ) ：客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上

# 未完待续

